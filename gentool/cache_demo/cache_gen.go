package main

import (
	"fmt"
	"github.com/cheny2151/go-toolbox/gentool/visitor"
	"github.com/cheny2151/go-toolbox/slicetool"
	"github.com/cheny2151/go-toolbox/stringtool"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const (
	head = `
// Code generated by cache_generate. DO NOT EDIT.

package {{.Pkg}}

import (
	{{range $val := .DependImports}}{{$val.Alias}} "{{$val.Pkg}}"
	{{end}}
)
`

	proxyStructTemp = `
type {{.name}} struct {
	origin	{{.StructInfo.Name}}
	rdb		redis.UniversalClient
}`

	originMethodsTemp = `
{{$root := .}}{{range $method := .StructInfo.OtherMethods }}
func (wrap *{{$root.name}}) ` + visitor.MethodSignatureTemp + ` {
	return wrap.origin.` + visitor.MethodCallTemp + `
}
{{end}}
`

	proxyMethodTemp = `
{{$root := .}}{{$method := $root.method }}
func (wrap *{{$root.name}}) ` + visitor.MethodSignatureTemp + ` {
	#{buildKey}
	#{getCache}
	result, err := wrap.origin.` + visitor.MethodCallTemp + `
	if err == nil {
		#{setCache}
	}
	return result, err
}
`

	getCacheTemp = `
	cache := rdb.Get(#{ctx}, key)
	err := cache.Err()
	if !errors.Is(err, redis.Nil) {
		#{logger:获取redis缓存异常:err}
	} else if err == nil {
		#{parserCache}	
	}
`
	setCacheTemp = "rdb.Set(#{ctx}, key, result, #{expireTime})"

	setJsonCacheTemp = `if result != nil {
		marshal, err := json.Marshal(result)
		if err != nil {
			#{logger:缓存redis，json序列化异常:err}
		} else {
			rdb.Set(ctx, key, string(marshal), time.Second)
		}
	}`

	parserJsonTemp = `var result #{resultType}
	bytes, _ := cache.Bytes()
	err := json.Unmarshal(bytes, &result)
	if err != nil {
		#{logger:获取redis缓存，反序列化异常:err}
	} else {
		return #{fixPoint:result}, nil
	}`

	defaultLogger = "fmt.Println(\"%s\",%s)"
)

const (
	proxyNameTemp = "%sCacheWrap"
)

func main() {
	sources := []string{"gentool/cache_demo/cache.go"}
	genSrc(sources, func(options *Options) {
		options.KeyPre = "ai:"
	})
}

type Options struct {
	Template  string
	OutputDir string
	KeyPre    string
}

type WithOption = func(options *Options)

func genSrc(sources []string, ops ...WithOption) {
	options := Options{}
	for _, op := range ops {
		op(&options)
	}

	for _, source := range sources {
		dir, file := filepath.Split(source)
		genFileName := strings.Split(file, ".")[0] + "_cache.go"
		structVisitor := visitor.ScanInterface(source,
			func(signature *visitor.StructInfo) bool {
				return strings.ContainsAny(signature.Doc, "@cache")
			}, func(signature *visitor.MethodSignature) bool {
				return strings.ContainsAny(signature.Doc, "@cacheMethod")
			})

		env := make(map[string]any)
		env[visitor.PkgFlag] = structVisitor.Pkg
		dependImports := []visitor.ImportInfo{
			{Pkg: "context"},
			{Pkg: "errors"},
			{Pkg: "fmt"},
			{Pkg: "github.com/redis/go-redis/v9"},
			{Pkg: "time"},
		}
		srcBuilder := strings.Builder{}
		srcBuilder.WriteString(head)

		for _, target := range structVisitor.Targets {
			src := buildCacheProxySrc(&dependImports, options, target)
			srcBuilder.WriteString(src)
		}

		dependImports = slicetool.Distinct(dependImports)
		env[visitor.DependImportsFlag] = dependImports

		// gen src with env
		fs, err := template.New("cache").Parse(srcBuilder.String())
		if err != nil {
			panic(err)
		}
		// 格式化
		source := visitor.ExeTemplate(fs, env)
		// 输出文件
		gofile, err := os.Create(dir + genFileName)
		if err != nil {
			panic(err)
		}
		defer gofile.Close()
		_, err = gofile.Write(source)
		if err != nil {
			panic(err)
		}
	}
}

type cacheParams struct {
	Key        string
	Expiration string
}

func buildCacheProxySrc(imports *[]visitor.ImportInfo, options Options, structInfo *visitor.StructInfo) string {
	structTmp, err := template.New("cache_struct").Parse(proxyStructTemp)
	if err != nil {
		panic(err)
	}

	name := fmt.Sprintf(proxyNameTemp, structInfo.Name)

	source := visitor.ExeTemplate(structTmp, map[string]any{visitor.StructFlag: structInfo, "name": name})
	builder := strings.Builder{}
	builder.Write(source)

	for _, method := range structInfo.TargetMethods {
		cacheInfo := cacheParams{}
		split := strings.Split(method.Doc, "\n")
		for _, line := range split {
			line = strings.TrimSpace(line)
			if strings.HasPrefix(line, "@") {
				lineSplit := strings.SplitN(line, ":", 2)
				argName := strings.ReplaceAll(strings.TrimSpace(lineSplit[0]), "@", "")
				argValue := strings.TrimSpace(lineSplit[1])
				if argName == "key" {
					cacheInfo.Key = argValue
				} else if argName == "expiration" {
					cacheInfo.Expiration = argValue
				}
			}
		}

		methodTemp := completeTemp(options, proxyMethodTemp, structInfo, method, cacheInfo)

		pmTmp, err := template.New("cache_proxy_method").Parse(methodTemp)
		if err != nil {
			panic(err)
		}

		if method.Results[0].TypeName != "bool" &&
			method.Results[0].TypeName != "int" &&
			method.Results[0].TypeName != "int64" &&
			method.Results[0].TypeName != "uint64" &&
			method.Results[0].TypeName != "float32" &&
			method.Results[0].TypeName != "float64" &&
			method.Results[0].TypeName != "string" {
			*imports = append(*imports, visitor.ImportInfo{Pkg: "encoding/json"})
		}

		methodSrc := visitor.ExeTemplate(pmTmp, map[string]any{visitor.StructFlag: structInfo, "name": name, "method": method})
		builder.Write(methodSrc)
	}

	omTmp, err := template.New("cache_other_methods").Parse(originMethodsTemp)
	if err != nil {
		panic(err)
	}
	builder.Write(visitor.ExeTemplate(omTmp, map[string]any{visitor.StructFlag: structInfo, "name": name}))
	return builder.String()
}

func completeTemp(options Options, temp string, info *visitor.StructInfo, method *visitor.MethodSignature, cacheInfo cacheParams) string {
	return stringtool.TokenParser(temp, "#{", "}", func(key string) string {
		split := strings.Split(key, ":")
		flag := split[0]
		switch flag {
		case "buildKey":
			keyArgs := make([]string, 0)
			keySrc := options.KeyPre + stringtool.TokenParser(cacheInfo.Key, "${", "}", func(key string) string {
				keyArgs = append(keyArgs, key)
				return "%v"
			})
			keyArgsSrc := strings.Join(keyArgs, ",")
			return fmt.Sprintf("key := fmt.Sprintf(\"%s\", %s)", keySrc, keyArgsSrc)
		case "getCache", "setCache", "parserCache", "fixPoint":
			results := method.Results
			resultLen := len(results)
			if resultLen != 2 || !method.ReturnErr {
				panic("cache method must return data,err")
			}

			methodBody := strings.Builder{}
			if flag == "getCache" {
				methodBody.WriteString(completeTemp(options, getCacheTemp, info, method, cacheInfo))
			} else {
				resultSign := results[0]
				switch resultSign.TypeName {
				case "bool", "int", "int64", "uint64", "float32", "float64", "string":
					callName := strings.ToUpper(resultSign.TypeName[0:1]) + resultSign.TypeName[1:] + "()"
					if flag == "parserCache" {
						methodBody.WriteString("return cache." + callName + ", nil")
					} else if flag == "setCache" {
						methodBody.WriteString(completeTemp(options, setCacheTemp, info, method, cacheInfo))
					} else if flag == "fixPoint" {
						methodBody.WriteString(split[1])
					}
				default:
					if flag == "parserCache" {
						methodBody.WriteString(completeTemp(options, parserJsonTemp, info, method, cacheInfo))
					} else if flag == "setCache" {
						methodBody.WriteString(completeTemp(options, setJsonCacheTemp, info, method, cacheInfo))
					} else if flag == "fixPoint" {
						if strings.HasPrefix(resultSign.TypeName, "[]") || strings.HasPrefix(resultSign.TypeName, "map") {
							methodBody.WriteString(split[1])
						} else {
							methodBody.WriteString("&" + split[1])
						}
					}
				}
			}

			return methodBody.String()
		case "logger":
			logTemp := options.Template
			if logTemp == "" {
				logTemp = defaultLogger
			}
			return fmt.Sprintf(logTemp, split[1], split[2])
		case "ctx":
			if method.CtxParamName != nil {
				return *method.CtxParamName
			} else {
				return "context.Background()"
			}
		case "resultType":
			return method.Results[0].TypeName
		case "expireTime":
			return cacheInfo.Expiration
		}
		panic("not support flag:" + flag)
	})
}
